#![cfg(target_os = "linux")]
//! Container service implementation.
//!
//! Handles OCI container lifecycle (Init RPC).

use std::path::Path;

use crate::service::server::GuestServer;
use boxlite_shared::{
    container_init_response, rootfs_init, Container as ContainerService, ContainerInitError,
    ContainerInitRequest, ContainerInitResponse, ContainerInitSuccess, Filesystem, RootfsInit,
};
use nix::mount::{mount, MsFlags};
use tonic::{Request, Response, Status};
use tracing::{debug, error, info};

use crate::container::{Container, UserMount};
use crate::layout::GuestLayout;
use crate::storage::block_device::BlockDeviceMount;

/// Prepare container rootfs based on the initialization strategy.
///
/// Handles three strategies:
/// - Merged: Shared rootfs already exists (no-op)
/// - Overlay: Bind-mount layers to diff dir, create overlayfs
/// - Disk: Mount block device to shared rootfs
fn prepare_rootfs(
    rootfs_init: &RootfsInit,
    container_id: &str,
    shared_rootfs: &Path,
    layout: &GuestLayout,
) -> Result<(), String> {
    match &rootfs_init.strategy {
        Some(rootfs_init::Strategy::Merged(_)) => {
            info!("Rootfs strategy: merged (using shared rootfs)");
            // Shared rootfs already exists, nothing to do
            Ok(())
        }
        Some(rootfs_init::Strategy::Overlay(overlay)) => {
            info!(
                "Rootfs strategy: overlay ({} layers, copy={})",
                overlay.layer_names.len(),
                overlay.copy_layers
            );

            // Bind-mount layers from convention-based path to container's diff dir
            let container_layout = layout.shared().container(container_id);
            let layers_source = container_layout.layers_dir();
            let diff_dir = container_layout.diff_dir();

            std::fs::create_dir_all(&diff_dir)
                .map_err(|e| format!("Failed to create diff dir: {}", e))?;

            mount(
                Some(layers_source.as_path()),
                &diff_dir,
                None::<&str>,
                MsFlags::MS_BIND,
                None::<&str>,
            )
            .map_err(|e| format!("Failed to bind-mount layers to diff: {}", e))?;

            // TODO: Create overlayfs and mount to shared_rootfs
            Ok(())
        }
        Some(rootfs_init::Strategy::Disk(disk)) => {
            info!("Rootfs strategy: disk (device={})", disk.device);

            std::fs::create_dir_all(shared_rootfs)
                .map_err(|e| format!("Failed to create shared rootfs directory: {}", e))?;

            // Mount container rootfs disk with options from host
            BlockDeviceMount::mount(
                Path::new(&disk.device),
                shared_rootfs,
                Filesystem::Ext4,
                disk.need_format,
                disk.need_resize,
            )
            .map_err(|e| format!("Failed to mount rootfs disk: {}", e))?;

            Ok(())
        }
        None => Err("Missing rootfs strategy in Container.Init request".to_string()),
    }
}

#[tonic::async_trait]
impl ContainerService for GuestServer {
    async fn init(
        &self,
        request: Request<ContainerInitRequest>,
    ) -> Result<Response<ContainerInitResponse>, Status> {
        let init_req = request.into_inner();
        info!("Received container init request");

        // Get container ID from request (generated by host)
        let container_id = init_req.container_id.clone();
        if container_id.is_empty() {
            error!("Missing container_id in Init request");
            return Ok(Response::new(ContainerInitResponse {
                result: Some(container_init_response::Result::Error(ContainerInitError {
                    reason: "Missing container_id in Init request".to_string(),
                })),
            }));
        }

        // Check if guest is initialized
        {
            let init_state = self.init_state.lock().await;
            if !init_state.initialized {
                error!("Guest not initialized (Guest.Init must be called first)");
                return Ok(Response::new(ContainerInitResponse {
                    result: Some(container_init_response::Result::Error(ContainerInitError {
                        reason: "Guest not initialized (Guest.Init must be called first)"
                            .to_string(),
                    })),
                }));
            }
        }

        // Extract container config
        let config = init_req
            .container_config
            .ok_or_else(|| Status::invalid_argument("Missing container_config in Init request"))?;

        // Validate configuration
        if config.entrypoint.is_empty() {
            error!("Invalid container config: entrypoint cannot be empty");
            return Ok(Response::new(ContainerInitResponse {
                result: Some(container_init_response::Result::Error(ContainerInitError {
                    reason: "Invalid container config: entrypoint cannot be empty".to_string(),
                })),
            }));
        }

        info!("ðŸš€ Starting OCI container with received configuration");

        // Compute rootfs paths from container_id
        // Shared rootfs: /run/boxlite/shared/containers/{cid}/rootfs
        // Bundle rootfs: /run/boxlite/containers/{cid}/rootfs (OCI bundle)
        let shared_rootfs = self.layout.shared().container(&container_id).rootfs_dir();
        let bundle_rootfs = self
            .layout
            .container_bundle_dir(&container_id)
            .join("rootfs");

        // Create bundle rootfs directory
        if let Err(e) = std::fs::create_dir_all(&bundle_rootfs) {
            error!("Failed to create bundle rootfs directory: {}", e);
            return Ok(Response::new(ContainerInitResponse {
                result: Some(container_init_response::Result::Error(ContainerInitError {
                    reason: format!("Failed to create bundle rootfs directory: {}", e),
                })),
            }));
        }

        // Handle rootfs initialization based on strategy
        let rootfs_init = init_req
            .rootfs
            .ok_or_else(|| Status::invalid_argument("Missing rootfs in Container.Init request"))?;

        if let Err(reason) =
            prepare_rootfs(&rootfs_init, &container_id, &shared_rootfs, &self.layout)
        {
            error!("{}", reason);
            return Ok(Response::new(ContainerInitResponse {
                result: Some(container_init_response::Result::Error(ContainerInitError {
                    reason,
                })),
            }));
        }

        // Bind mount shared rootfs to bundle rootfs
        if let Err(e) = mount(
            Some(shared_rootfs.as_path()),
            &bundle_rootfs,
            None::<&str>,
            MsFlags::MS_BIND,
            None::<&str>,
        ) {
            error!("Failed to bind mount rootfs: {}", e);
            return Ok(Response::new(ContainerInitResponse {
                result: Some(container_init_response::Result::Error(ContainerInitError {
                    reason: format!("Failed to bind mount rootfs: {}", e),
                })),
            }));
        }

        // Convert proto BindMount to UserMount for OCI spec
        // Construct full source path from convention: /run/boxlite/shared/containers/{id}/volumes/{name}
        let guest_layout = boxlite_shared::layout::SharedGuestLayout::new("/run/boxlite/shared");
        let container_layout = guest_layout.container(&container_id);

        let user_mounts: Vec<UserMount> = init_req
            .mounts
            .iter()
            .map(|m| {
                let source = container_layout.volume_dir(&m.volume_name);
                UserMount {
                    source: source.to_string_lossy().to_string(),
                    destination: m.destination.clone(),
                    read_only: m.read_only,
                }
            })
            .collect();

        debug!(
            entrypoint = ?config.entrypoint,
            workdir = %config.workdir,
            env_count = config.env.len(),
            shared_rootfs = %shared_rootfs.display(),
            bundle_rootfs = %bundle_rootfs.display(),
            container_id = %container_id,
            user_mounts_count = user_mounts.len(),
            "Container configuration"
        );

        // Start container using OCI bundle rootfs
        // Container init process uses pipe-based stdio to stay alive indefinitely.
        // boxlite-guest holds the write-end of stdin pipe open, so init blocks on read() forever.
        debug!(
            container_id = %container_id,
            entrypoint = ?config.entrypoint,
            "Starting OCI container with pipe-based stdio"
        );
        match Container::start(
            &container_id,
            &bundle_rootfs,
            config.entrypoint,
            config.env,
            &config.workdir,
            user_mounts,
        ) {
            Ok(container) => {
                debug!(container_id = %container_id, "Container started, checking if init process is running");
                // Verify container init process is running
                if !container.is_running() {
                    // Gather diagnostic information
                    let diagnostics = container.diagnose_exit();

                    error!(
                        "Container init process exited immediately after start. Diagnostics: {}",
                        diagnostics
                    );

                    return Ok(Response::new(ContainerInitResponse {
                        result: Some(container_init_response::Result::Error(ContainerInitError {
                            reason: format!(
                                "Container init process exited immediately. {}",
                                diagnostics
                            ),
                        })),
                    }));
                }

                info!(
                    container_id = %container_id,
                    "âœ… Container started successfully and ready for exec"
                );

                // Store container in registry
                self.containers.lock().await.insert(
                    container_id.clone(),
                    std::sync::Arc::new(tokio::sync::Mutex::new(container)),
                );

                Ok(Response::new(ContainerInitResponse {
                    result: Some(container_init_response::Result::Success(
                        ContainerInitSuccess { container_id },
                    )),
                }))
            }
            Err(e) => {
                error!("Failed to start container: {}", e);
                Ok(Response::new(ContainerInitResponse {
                    result: Some(container_init_response::Result::Error(ContainerInitError {
                        reason: format!("Failed to start container: {}", e),
                    })),
                }))
            }
        }
    }
}
