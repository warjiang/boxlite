//! Container service interface.

use boxlite_shared::{
    BindMount, BoxliteError, BoxliteResult, ContainerClient,
    ContainerConfig as ProtoContainerConfig, ContainerInitRequest, DiskRootfs, MergedRootfs,
    OverlayRootfs, RootfsInit, container_init_response,
};
use tonic::transport::Channel;

use crate::volumes::ContainerMount;

/// Container rootfs initialization strategy.
/// Guest constructs paths from container_id using its own layout knowledge.
#[derive(Debug, Clone)]
pub enum ContainerRootfsInitConfig {
    /// Single merged rootfs - guest constructs path from container_id
    #[allow(dead_code)] // Reserved for future merged rootfs mode
    Merged,
    /// Overlayfs from multiple layers - guest constructs paths from container_id and layer_names
    #[allow(dead_code)] // Reserved for future overlayfs mode
    Overlay {
        /// Layer directory names (e.g., "sha256-abc123")
        layer_names: Vec<String>,
        /// Whether to copy layers to disk before overlayfs (default: true)
        copy_layers: bool,
    },
    /// Disk-based rootfs - block device mounted directly as container rootfs
    DiskImage {
        /// Block device path (e.g., "/dev/vda")
        device: String,
        /// Whether to format the device before mounting
        need_format: bool,
        /// Whether to resize filesystem after mounting to fill disk
        need_resize: bool,
    },
}

impl ContainerRootfsInitConfig {
    pub(crate) fn into_proto(self) -> RootfsInit {
        match self {
            ContainerRootfsInitConfig::Merged => RootfsInit {
                strategy: Some(boxlite_shared::rootfs_init::Strategy::Merged(
                    MergedRootfs {},
                )),
            },
            ContainerRootfsInitConfig::Overlay {
                layer_names,
                copy_layers,
            } => RootfsInit {
                strategy: Some(boxlite_shared::rootfs_init::Strategy::Overlay(
                    OverlayRootfs {
                        layer_names,
                        copy_layers,
                    },
                )),
            },
            ContainerRootfsInitConfig::DiskImage {
                device,
                need_format,
                need_resize,
            } => RootfsInit {
                strategy: Some(boxlite_shared::rootfs_init::Strategy::Disk(DiskRootfs {
                    device,
                    need_format,
                    need_resize,
                })),
            },
        }
    }
}

/// Container service interface.
pub struct ContainerInterface {
    client: ContainerClient<Channel>,
}

impl ContainerInterface {
    /// Create from a channel.
    pub fn new(channel: Channel) -> Self {
        Self {
            client: ContainerClient::new(channel),
        }
    }

    /// Initialize container with configuration.
    ///
    /// # Arguments
    /// * `container_id` - Container ID (generated by host)
    /// * `image_config` - Image-derived container config (entrypoint, env, workdir)
    /// * `rootfs` - Rootfs initialization strategy
    /// * `mounts` - Bind mounts from guest VM paths into container
    ///
    /// # Returns
    /// Container ID on success
    pub async fn init(
        &mut self,
        container_id: &str,
        image_config: crate::images::ContainerImageConfig,
        rootfs: ContainerRootfsInitConfig,
        mounts: Vec<ContainerMount>,
    ) -> BoxliteResult<String> {
        let proto_config = ProtoContainerConfig {
            entrypoint: image_config.cmd.clone(),
            env: image_config.env.clone(),
            workdir: image_config.working_dir.clone(),
        };

        // Convert ContainerMount to proto BindMount
        // Uses convention-based paths - guest will construct full path from volume_name
        let proto_mounts: Vec<BindMount> = mounts
            .into_iter()
            .map(|m| BindMount {
                volume_name: m.volume_name,
                destination: m.destination,
                read_only: m.read_only,
            })
            .collect();

        tracing::debug!(container_id = %container_id, "Sending ContainerInit request");
        tracing::trace!(
            container_id = %container_id,
            entrypoint = ?image_config.cmd,
            workdir = %image_config.working_dir,
            env_count = image_config.env.len(),
            rootfs = ?rootfs,
            mounts_count = proto_mounts.len(),
            "Container configuration"
        );

        let request = ContainerInitRequest {
            container_id: container_id.to_string(),
            container_config: Some(proto_config),
            rootfs: Some(rootfs.into_proto()),
            mounts: proto_mounts,
        };

        let response = self.client.init(request).await?.into_inner();

        match response.result {
            Some(container_init_response::Result::Success(success)) => {
                tracing::debug!(container_id = %success.container_id, "Container initialized");
                Ok(success.container_id)
            }
            Some(container_init_response::Result::Error(err)) => {
                tracing::error!(container_id = %container_id, "Container init failed: {}", err.reason);
                Err(BoxliteError::Internal(format!(
                    "Container init failed: {}",
                    err.reason
                )))
            }
            None => Err(BoxliteError::Internal(
                "ContainerInit response missing result".to_string(),
            )),
        }
    }
}
